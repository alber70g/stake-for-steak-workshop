"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('cross-fetch');
const cryptography_utils_1 = require("@kadena/cryptography-utils");
const local_1 = require("../local");
const mockFetch_1 = require("./mockdata/mockFetch");
const Pact_1 = require("./mockdata/Pact");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const mockedFunctionFetch = cross_fetch_1.default;
mockedFunctionFetch.mockImplementation(mockFetch_1.mockFetch);
test('/local should return result of tx queried', async () => {
    const commandStr1 = JSON.stringify(Pact_1.pactTestCommand);
    const keyPair1 = {
        publicKey: 'ba54b224d1924dd98403f5c751abdd10de6cd81b0121800bf7bdbdcfaec7388d',
        secretKey: '8693e641ae2bbe9ea802c736f42027b03f86afe63cae315e7169c9c496c17332',
    };
    const cmdWithOneSignature1 = (0, cryptography_utils_1.sign)(commandStr1, keyPair1);
    const signedCommand1 = {
        cmd: commandStr1,
        hash: cmdWithOneSignature1.hash,
        sigs: [{ sig: cmdWithOneSignature1.sig }],
    };
    const commandResult1 = {
        reqKey: 'uolsidh4DWN-D44FoElnosL8e5-cGCGn_0l2Nct5mq8',
        txId: null,
        result: {
            data: 3,
            status: 'success',
        },
        gas: 0,
        continuation: null,
        metaData: null,
        logs: 'wsATyGqckuIvlm89hhd2j4t6RMkCrcwJe_oeCYr7Th8',
    };
    const localReq = signedCommand1;
    const responseExpected = commandResult1;
    const responseActual = await (0, local_1.local)(localReq, '');
    expect(responseExpected).toEqual(responseActual);
});
//# sourceMappingURL=local.test.js.map