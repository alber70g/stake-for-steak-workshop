import { ChainId } from '@kadena/types';
import { ChainwebNetworkId } from '@kadena/types';
import { ICap } from '@kadena/types';
import { ICommand } from '@kadena/types';
import { ICommandResult } from '@kadena/types';
import { IPollResponse } from '@kadena/types';
import { ISendResponse } from '@kadena/chainweb-node-client';
import { ISignature } from '@kadena/types';
import { PactValue } from '@kadena/types';

/**
 * @alpha
 */
export declare function buildCommandFromTemplate(parts: string[], holes: string[], args: Record<string, string>): string;

/**
 * @internal
 */
export declare function buildUnsignedTransaction(parts: string[], holes: string[], args: Record<string, string>): IPactCommand & ICommandBuilder<{}>;

/**
 * @alpha
 */
export declare function createPactCommandFromTemplate(tpl: IPactCommand): PactCommand;

/**
 * @alpha
 */
export declare interface IChainweaverQuickSignRequestBody {
    reqs: IUnsignedTransaction[];
}

/**
 * @alpha
 */
export declare type IChainweaverSig = string;

/**
 * @alpha
 */
export declare interface IChainweaverSignedCommand {
    sigs: {
        [pubkey: string]: IChainweaverSig;
    };
    cmd: string;
}

/**
 * @alpha
 */
export declare interface ICommandBuilder<TCaps extends Record<string, TArgs>, TArgs extends Array<TCaps[keyof TCaps]> = TCaps[keyof TCaps]> {
    createCommand(): ICommand;
    addData: (data: IPactCommand['data']) => ICommandBuilder<TCaps, TArgs> & IPactCommand;
    setMeta: (publicMeta: Partial<IPactCommand['publicMeta']> & {
        sender: IPactCommand['publicMeta']['sender'];
    }, networkId?: IPactCommand['networkId']) => ICommandBuilder<TCaps, TArgs> & IPactCommand;
    addCap<TCap extends keyof TCaps>(caps: TCap, signer: string, ...args: TCaps[TCap]): ICommandBuilder<TCaps, TArgs> & IPactCommand;
    local(apiHost: string): Promise<ICommandResult>;
    send(apiHost: string): Promise<ISendResponse>;
    poll(apiHost: string): Promise<IPollResponse>;
    addSignatures(...sig: {
        pubkey: string;
        sig: string;
    }[]): ICommandBuilder<TCaps, TArgs> & IPactCommand;
}

/**
 * @alpha
 */
export declare interface IPact {
    modules: IPactModules;
}

/**
 * @alpha
 */
export declare interface IPactCommand {
    code: string;
    data: Record<string, unknown>;
    publicMeta: IPublicMeta;
    networkId: Exclude<ChainwebNetworkId, undefined>;
    signers: {
        pubKey: string;
        caps: {
            name: string;
            args: ICap['args'];
        }[];
    }[];
    type: string;
    sigs: (ISignature | undefined)[];
}

/**
 * @alpha
 */
export declare interface IPactModules {
}

/**
 * @alpha
 */
export declare interface IPublicMeta {
    chainId: ChainId;
    sender: string;
    gasLimit: number;
    gasPrice: number;
    ttl: number;
}

/**
 * @alpha
 */
export declare interface ITemplate {
    parts: TemplateParts;
    holes: TemplateHoles;
}

/**
 * @alpha
 */
export declare interface IUnsignedTransaction {
    hash: string;
    sigs: {
        [pubkey: string]: string | null;
    };
    cmd: string;
}

/**
 * @alpha
 */
export declare type NonceFactory = (t: IPactCommand, dateInMs: number) => NonceType;

/**
 * @alpha
 */
export declare type NonceType = string;

/**
 * @alpha
 */
export declare const Pact: IPact;

/**
 * @alpha
 */
export declare class PactCommand implements IPactCommand, ICommandBuilder<Record<string, unknown>> {
    code: string;
    data: Record<string, unknown>;
    publicMeta: {
        chainId: ChainId;
        sender: string;
        gasLimit: number;
        gasPrice: number;
        ttl: number;
    };
    networkId: Exclude<ChainwebNetworkId, undefined>;
    signers: {
        pubKey: string;
        caps: {
            name: string;
            args: ICap['args'];
        }[];
    }[];
    sigs: (ISignature | undefined)[];
    type: 'exec';
    cmd: string | undefined;
    requestKey: string | undefined;
    constructor();
    /**
     * If a non-malleable (finalized) transaction gets altered after
     * running createCommand, we need to recalculate the hash and
     * remove the signatures as these do not match with the transaction anymore.
     * Each signature in this.sigs will be replaced with undefined so the length
     * of the array matches with this.signers.
     */
    private _unfinalizeTransaction;
    /**
     * A function that is generated based on IPactCommand and the creation date.
     * This is called during execution of `createCommand()` and adds `nonce` to
     * the command.
     * @param t - transaction
     * @param dateInMs - date in milliseconds from epoch
     * @returns string that will be created during `createCommand()`
     */
    nonceCreator(t: IPactCommand, dateInMs: number): NonceType;
    /**
     * Create a command that's compatible with the blockchain
     * @returns a command that can be send to the blockchain
     * (see https://api.chainweb.com/openapi/pact.html#tag/endpoint-send/paths/~1send/post)
     */
    createCommand(): ICommand;
    addData(data: IPactCommand['data']): this;
    setMeta(publicMeta: Partial<IPactCommand['publicMeta']>, networkId?: IPactCommand['networkId']): this;
    addCap<T extends Array<PactValue> = Array<PactValue>>(capability: string, signer: string, ...args: T[]): this;
    /**
     * Sends a transaction to the ApiHost /local to test the transaction
     * (i.e. it is checked whether the signatures are complete)
     * @param apiHost - the chainweb host where to send the transaction to
     * @alpha
     */
    local(apiHost: string): Promise<ICommandResult>;
    /**
     * Sends a transaction to the ApiHost /send when the transaction is finalized
     * (i.e. it is checked whether the signatures are complete)
     * @param apiHost - the chainweb host where to send the transaction to
     * @alpha
     */
    send(apiHost: string): Promise<ISendResponse>;
    poll(apiHost: string): Promise<IPollResponse>;
    addSignatures(...sigs: {
        pubkey: string;
        sig: string;
    }[]): this;
}

/**
 * @alpha
 */
export declare function signWithChainweaver<T1 extends string, T2>(...transactions: (IPactCommand & ICommandBuilder<Record<T1, T2>>)[]): Promise<(IPactCommand & ICommandBuilder<Record<T1, T2>>)[]>;

/**
 * @alpha
 */
export declare type TemplateHoles = string[];

/**
 * @alpha
 */
export declare type TemplateParts = string[];

export { }
