"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pact = exports.createPactCommandFromTemplate = exports.PactCommand = void 0;
const chainweb_node_client_1 = require("@kadena/chainweb-node-client");
const cryptography_utils_1 = require("@kadena/cryptography-utils");
const pactjs_1 = require("@kadena/pactjs");
const parseType_1 = require("./utils/parseType");
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('pactjs:proxy');
/**
 * @alpha
 */
class PactCommand {
    constructor() {
        // public signer:
        //   | ((
        //       ...transactions: (IPactCommand &
        //         ICommandBuilder<Record<string, unknown>>)[]
        //     ) => Promise<this>)
        //   | undefined;
        this.type = 'exec';
        this.code = '';
        this.data = {};
        this.publicMeta = {
            chainId: '1',
            gasLimit: 2500,
            gasPrice: 1.0e-8,
            sender: '',
            ttl: 8 * 60 * 60, // 8 hours,
        };
        this.networkId = 'testnet04';
        this.signers = [];
        this.sigs = [];
    }
    /**
     * If a non-malleable (finalized) transaction gets altered after
     * running createCommand, we need to recalculate the hash and
     * remove the signatures as these do not match with the transaction anymore.
     * Each signature in this.sigs will be replaced with undefined so the length
     * of the array matches with this.signers.
     */
    _unfinalizeTransaction() {
        this.cmd = undefined;
        this.sigs = this.sigs.map(() => undefined);
    }
    /**
     * A function that is generated based on IPactCommand and the creation date.
     * This is called during execution of `createCommand()` and adds `nonce` to
     * the command.
     * @param t - transaction
     * @param dateInMs - date in milliseconds from epoch
     * @returns string that will be created during `createCommand()`
     */
    nonceCreator(t, dateInMs) {
        return 'kjs ' + new Date(dateInMs).toISOString();
    }
    /**
     * Create a command that's compatible with the blockchain
     * @returns a command that can be send to the blockchain
     * (see https://api.chainweb.com/openapi/pact.html#tag/endpoint-send/paths/~1send/post)
     */
    createCommand() {
        const dateInMs = Date.now();
        // convert to IUnsignedTransactionCommand
        const unsignedTransactionCommand = {
            networkId: this.networkId,
            payload: {
                exec: {
                    data: this.data,
                    code: this.code,
                },
            },
            signers: this.signers.map((signer) => ({
                pubKey: signer.pubKey,
                clist: signer.caps,
            })),
            meta: Object.assign(Object.assign({}, this.publicMeta), { creationTime: Math.floor(dateInMs / 1000) }),
            nonce: this.nonceCreator(this, dateInMs),
        };
        // stringify command
        const cmd = this.cmd !== undefined
            ? this.cmd
            : JSON.stringify(unsignedTransactionCommand);
        // hash command
        const hash = (0, cryptography_utils_1.hash)(cmd);
        // convert to IUnsignedTransaction
        const command = {
            hash,
            sigs: this.sigs.map((s) => (s === undefined ? { sig: '' } : s)),
            cmd,
        };
        this.cmd = command.cmd;
        return command;
    }
    addData(data) {
        this._unfinalizeTransaction();
        this.data = data;
        return this;
    }
    setMeta(publicMeta, networkId = 'mainnet01') {
        this._unfinalizeTransaction();
        this.publicMeta = Object.assign(this.publicMeta, publicMeta);
        this.networkId = networkId;
        return this;
    }
    addCap(capability, signer, ...args) {
        this._unfinalizeTransaction();
        const signerIndex = this.signers.findIndex((s) => s.pubKey === signer);
        if (signerIndex === -1) {
            // signer not found
            // push new signer to this.signers
            this.signers.push({
                pubKey: signer,
                caps: [{ name: capability, args }],
            });
            // push undefined to make sure this.sigs matches the length (and position) of this.signers
            this.sigs.push(undefined);
        }
        else {
            // add cap to existing signer
            this.signers[signerIndex].caps.push({ name: capability, args });
        }
        return this;
    }
    /**
     * Sends a transaction to the ApiHost /local to test the transaction
     * (i.e. it is checked whether the signatures are complete)
     * @param apiHost - the chainweb host where to send the transaction to
     * @alpha
     */
    local(apiHost) {
        log(`calling local with: ${JSON.stringify(this.createCommand(), null, 2)}`);
        return (0, chainweb_node_client_1.local)(this.createCommand(), apiHost);
    }
    /**
     * Sends a transaction to the ApiHost /send when the transaction is finalized
     * (i.e. it is checked whether the signatures are complete)
     * @param apiHost - the chainweb host where to send the transaction to
     * @alpha
     */
    async send(apiHost) {
        const sendResponse = await (0, chainweb_node_client_1.send)({ cmds: [this.createCommand()] }, apiHost);
        this.requestKey = sendResponse.requestKeys[0].toString();
        return sendResponse;
    }
    poll(apiHost) {
        if (this.requestKey === undefined) {
            throw new Error('`requestKey` not found' +
                '\nThis request might not be send yet, or it possibly failed.');
        }
        return (0, chainweb_node_client_1.poll)({ requestKeys: [this.requestKey] }, apiHost);
    }
    addSignatures(...sigs) {
        sigs.forEach(({ pubkey, sig }) => {
            const foundSignerIndex = this.signers.findIndex(({ pubKey }) => pubKey === pubkey);
            if (foundSignerIndex === -1) {
                throw new Error('Cannot add signature, public key not present');
            }
            this.sigs[foundSignerIndex] = { sig };
        });
        return this;
    }
}
exports.PactCommand = PactCommand;
/**
 * @alpha
 */
function createPactCommandFromTemplate(tpl) {
    const pactCommand = Object.assign(new PactCommand(), tpl);
    log(`createPactCommandFromTemplate returns ${pactCommand}`);
    return pactCommand;
}
exports.createPactCommandFromTemplate = createPactCommandFromTemplate;
const pactCreator = () => {
    const transaction = new PactCommand();
    const ThePact = new Proxy(function () { }, {
        get(target, p) {
            log('get', p);
            if (typeof p === 'string')
                if (transaction.code.length !== 0) {
                    transaction.code += '.' + p;
                }
                else {
                    transaction.code += p;
                }
            return ThePact;
        },
        apply(target, that, args) {
            // when the expression is called, finalize the call
            // e.g.: `Pact.modules.coin.transfer(...someArgs)`
            log('apply', args);
            transaction.code = (0, pactjs_1.createExp)(transaction.code, ...args.map(parseType_1.parseType));
            return transaction;
        },
    });
    return ThePact;
};
/**
 * @alpha
 */
exports.Pact = {
    get modules() {
        return pactCreator();
    },
};
//# sourceMappingURL=pact.js.map