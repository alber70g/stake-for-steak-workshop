{"version":3,"file":"pact.js","sourceRoot":"","sources":["../src/pact.ts"],"names":[],"mappings":"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","sourcesContent":["import { ISendResponse, local, poll, send } from '@kadena/chainweb-node-client';\nimport { hash as blakeHash } from '@kadena/cryptography-utils';\nimport { createExp } from '@kadena/pactjs';\nimport {\n  ChainId,\n  ChainwebNetworkId,\n  ICap,\n  ICommand,\n  ICommandPayload,\n  ICommandResult,\n  IPollResponse,\n  ISignature,\n  PactValue,\n} from '@kadena/types';\n\nimport { IPactCommand } from './interfaces/IPactCommand';\nimport { parseType } from './utils/parseType';\n\nimport debug, { Debugger } from 'debug';\n\nconst log: Debugger = debug('pactjs:proxy');\n\n/**\n * @alpha\n */\nexport interface ICommandBuilder<\n  TCaps extends Record<string, TArgs>,\n  TArgs extends Array<TCaps[keyof TCaps]> = TCaps[keyof TCaps],\n> {\n  createCommand(): ICommand;\n  addData: (\n    data: IPactCommand['data'],\n  ) => ICommandBuilder<TCaps, TArgs> & IPactCommand;\n  setMeta: (\n    publicMeta: Partial<IPactCommand['publicMeta']> & {\n      sender: IPactCommand['publicMeta']['sender'];\n    },\n    networkId?: IPactCommand['networkId'],\n  ) => ICommandBuilder<TCaps, TArgs> & IPactCommand;\n  addCap<TCap extends keyof TCaps>(\n    caps: TCap,\n    signer: string,\n    ...args: TCaps[TCap]\n  ): ICommandBuilder<TCaps, TArgs> & IPactCommand;\n  local(apiHost: string): Promise<ICommandResult>;\n  send(apiHost: string): Promise<ISendResponse>;\n  poll(apiHost: string): Promise<IPollResponse>;\n  addSignatures(\n    ...sig: {\n      pubkey: string;\n      sig: string;\n    }[]\n  ): ICommandBuilder<TCaps, TArgs> & IPactCommand;\n  // setSigner(\n  //   fn: (\n  //     ...transactions: (IPactCommand &\n  //       ICommandBuilder<Record<string, unknown>>)[]\n  //   ) => Promise<this>,\n  // ): ICommandBuilder<TCaps, TArgs> & IPactCommand;\n}\n\n/**\n * @alpha\n */\nexport interface IPactModules {}\n\n/**\n * @alpha\n */\nexport interface IPact {\n  modules: IPactModules;\n}\n\n/**\n * @alpha\n */\nexport type NonceType = string;\n\n/**\n * @alpha\n */\nexport type NonceFactory = (t: IPactCommand, dateInMs: number) => NonceType;\n\n/**\n * @alpha\n */\nexport class PactCommand\n  implements IPactCommand, ICommandBuilder<Record<string, unknown>>\n{\n  public code: string;\n  public data: Record<string, unknown>;\n  public publicMeta: {\n    chainId: ChainId;\n    sender: string;\n    gasLimit: number;\n    gasPrice: number;\n    ttl: number;\n  };\n  public networkId: Exclude<ChainwebNetworkId, undefined>;\n  public signers: {\n    pubKey: string;\n    caps: {\n      name: string;\n      args: ICap['args'];\n    }[];\n  }[];\n  public sigs: (ISignature | undefined)[];\n  // public signer:\n  //   | ((\n  //       ...transactions: (IPactCommand &\n  //         ICommandBuilder<Record<string, unknown>>)[]\n  //     ) => Promise<this>)\n  //   | undefined;\n  public type: 'exec' = 'exec';\n  public cmd: string | undefined;\n  public requestKey: string | undefined;\n\n  public constructor() {\n    this.code = '';\n    this.data = {};\n    this.publicMeta = {\n      chainId: '1',\n      gasLimit: 2500,\n      gasPrice: 1.0e-8,\n      sender: '',\n      ttl: 8 * 60 * 60, // 8 hours,\n    };\n    this.networkId = 'testnet04';\n    this.signers = [];\n    this.sigs = [];\n  }\n\n  /**\n   * If a non-malleable (finalized) transaction gets altered after\n   * running createCommand, we need to recalculate the hash and\n   * remove the signatures as these do not match with the transaction anymore.\n   * Each signature in this.sigs will be replaced with undefined so the length\n   * of the array matches with this.signers.\n   */\n  private _unfinalizeTransaction(): void {\n    this.cmd = undefined;\n    this.sigs = this.sigs.map(() => undefined);\n  }\n\n  /**\n   * A function that is generated based on IPactCommand and the creation date.\n   * This is called during execution of `createCommand()` and adds `nonce` to\n   * the command.\n   * @param t - transaction\n   * @param dateInMs - date in milliseconds from epoch\n   * @returns string that will be created during `createCommand()`\n   */\n  public nonceCreator(t: IPactCommand, dateInMs: number): NonceType {\n    return 'kjs ' + new Date(dateInMs).toISOString();\n  }\n\n  /**\n   * Create a command that's compatible with the blockchain\n   * @returns a command that can be send to the blockchain\n   * (see https://api.chainweb.com/openapi/pact.html#tag/endpoint-send/paths/~1send/post)\n   */\n  public createCommand(): ICommand {\n    const dateInMs: number = Date.now();\n\n    // convert to IUnsignedTransactionCommand\n    const unsignedTransactionCommand: ICommandPayload = {\n      networkId: this.networkId,\n      payload: {\n        exec: {\n          data: this.data,\n          code: this.code,\n        },\n      },\n      signers: this.signers.map((signer) => ({\n        pubKey: signer.pubKey,\n        clist: signer.caps,\n      })),\n      meta: { ...this.publicMeta, creationTime: Math.floor(dateInMs / 1000) },\n      nonce: this.nonceCreator(this, dateInMs),\n    };\n\n    // stringify command\n    const cmd: string =\n      this.cmd !== undefined\n        ? this.cmd\n        : JSON.stringify(unsignedTransactionCommand);\n\n    // hash command\n    const hash = blakeHash(cmd);\n\n    // convert to IUnsignedTransaction\n    const command: ICommand = {\n      hash,\n      sigs: this.sigs.map((s) => (s === undefined ? { sig: '' } : s)),\n      cmd,\n    };\n\n    this.cmd = command.cmd;\n    return command;\n  }\n\n  public addData(data: IPactCommand['data']): this {\n    this._unfinalizeTransaction();\n\n    this.data = data;\n    return this;\n  }\n\n  public setMeta(\n    publicMeta: Partial<IPactCommand['publicMeta']>,\n    networkId: IPactCommand['networkId'] = 'mainnet01',\n  ): this {\n    this._unfinalizeTransaction();\n\n    this.publicMeta = Object.assign(this.publicMeta, publicMeta);\n    this.networkId = networkId;\n    return this;\n  }\n\n  public addCap<T extends Array<PactValue> = Array<PactValue>>(\n    capability: string,\n    signer: string,\n    ...args: T[]\n  ): this {\n    this._unfinalizeTransaction();\n\n    const signerIndex: number = this.signers.findIndex(\n      (s) => s.pubKey === signer,\n    );\n\n    if (signerIndex === -1) {\n      // signer not found\n      // push new signer to this.signers\n      this.signers.push({\n        pubKey: signer,\n        caps: [{ name: capability, args }],\n      });\n      // push undefined to make sure this.sigs matches the length (and position) of this.signers\n      this.sigs.push(undefined);\n    } else {\n      // add cap to existing signer\n      this.signers[signerIndex].caps.push({ name: capability, args });\n    }\n    return this;\n  }\n\n  /**\n   * Sends a transaction to the ApiHost /local to test the transaction\n   * (i.e. it is checked whether the signatures are complete)\n   * @param apiHost - the chainweb host where to send the transaction to\n   * @alpha\n   */\n  public local(apiHost: string): Promise<ICommandResult> {\n    log(`calling local with: ${JSON.stringify(this.createCommand(), null, 2)}`);\n\n    return local(this.createCommand(), apiHost);\n  }\n\n  /**\n   * Sends a transaction to the ApiHost /send when the transaction is finalized\n   * (i.e. it is checked whether the signatures are complete)\n   * @param apiHost - the chainweb host where to send the transaction to\n   * @alpha\n   */\n  public async send(apiHost: string): Promise<ISendResponse> {\n    const sendResponse = await send({ cmds: [this.createCommand()] }, apiHost);\n    this.requestKey = sendResponse.requestKeys[0].toString();\n    return sendResponse;\n  }\n\n  public poll(apiHost: string): Promise<IPollResponse> {\n    if (this.requestKey === undefined) {\n      throw new Error(\n        '`requestKey` not found' +\n          '\\nThis request might not be send yet, or it possibly failed.',\n      );\n    }\n    return poll({ requestKeys: [this.requestKey] }, apiHost);\n  }\n\n  public addSignatures(...sigs: { pubkey: string; sig: string }[]): this {\n    sigs.forEach(({ pubkey, sig }) => {\n      const foundSignerIndex = this.signers.findIndex(\n        ({ pubKey }) => pubKey === pubkey,\n      );\n      if (foundSignerIndex === -1) {\n        throw new Error('Cannot add signature, public key not present');\n      }\n      this.sigs[foundSignerIndex] = { sig };\n    });\n    return this;\n  }\n\n  // public setSigner(\n  //   fn: (\n  //     ...transactions: (IPactCommand &\n  //       ICommandBuilder<Record<string, unknown>>)[]\n  //   ) => Promise<this>,\n  // ): this {\n  //   this.signer = fn;\n  //   return this;\n  // }\n}\n\n/**\n * @alpha\n */\nexport function createPactCommandFromTemplate(tpl: IPactCommand): PactCommand {\n  const pactCommand = Object.assign(new PactCommand(), tpl);\n  log(`createPactCommandFromTemplate returns ${pactCommand}`);\n  return pactCommand;\n}\n\nconst pactCreator = (): IPact => {\n  const transaction: PactCommand = new PactCommand();\n  const ThePact: IPact = new Proxy(function () {} as unknown as IPact, {\n    get(target: unknown, p: string): IPact {\n      log('get', p);\n      if (typeof p === 'string')\n        if (transaction.code.length !== 0) {\n          transaction.code += '.' + p;\n        } else {\n          transaction.code += p;\n        }\n      return ThePact;\n    },\n    apply(\n      target: unknown,\n      that: unknown,\n      args: Array<string | number | boolean>,\n    ) {\n      // when the expression is called, finalize the call\n      // e.g.: `Pact.modules.coin.transfer(...someArgs)`\n      log('apply', args);\n      transaction.code = createExp(transaction.code, ...args.map(parseType));\n      return transaction;\n    },\n  }) as IPact;\n  return ThePact;\n};\n\n/**\n * @alpha\n */\nexport const Pact: IPact = {\n  get modules() {\n    return pactCreator();\n  },\n};\n"]}